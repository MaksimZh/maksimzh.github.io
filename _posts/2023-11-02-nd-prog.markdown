---
layout: post
title:  "Многомерное программирование"
date:   2023-11-02
---

Помню, что обещал писать про квантовую механику, но я изменил своё решение.
Лучше буду писать здесь про программирование.

В среднем, человек получает 80% информации с помощью зрения.
Благодаря тому, что мы воспринимаем изображение сразу от двух глаз и
тому, что сам мозг достраивает его на основе предыдущего опыта,
мы получаем трёхмерный образ.
Или даже четырёхмерный - это если картинка динамичная.
При этом, при хранении и передаче информации часто приходится упаковывать
её в одномерном формате - в виде речи или текста.
И то и другое - линейный поток звуков или символов из которого мозг потом
строит многомерный образ.

Нам удобно обрабатывать информацию именно так - в многомерном виде,
где оптимальное количество измерений от 2х до 4х.
Осознанно или нет, мы повышаем размерность даже при работе с текстом.
Помните как в школе мы искали в предложении подлежащее, сказуемое и прочие
дополнения с обстоятельствами?
Фактически мы строили
[абстрактное синтаксическое дерево](https://ru.wikipedia.org/wiki/%D0%90%D0%B1%D1%81%D1%82%D1%80%D0%B0%D0%BA%D1%82%D0%BD%D0%BE%D0%B5_%D1%81%D0%B8%D0%BD%D1%82%D0%B0%D0%BA%D1%81%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%BE%D0%B5_%D0%B4%D0%B5%D1%80%D0%B5%D0%B2%D0%BE) -
двумерный объект, который показывает, как разные части предложения связаны
друг с другом.
Ну хорошо, в явном виде дерево мы не строили (и совершенно напрасно, я считаю),
но ещё одно измерение в виде разных стилей подчёркивания точно добавлялось.
Это же буквально подсветка синтаксиса!

При работе с информацией мы постоянно повышаем размерность.
Многоуровневое оглавление добавляет тексту глубину.
Таблицы принципиально двумерны.
Графики минимум двумерны, а иногда и трёхмерны.
В математических формулах дроби переключают нас с горизонтального восприятия
на вертикальное, а корни и интегралы добавляют уровни вложенности (глубину).
Есть ещё списки, сноски, ссылки (и гиперссылки) и т.п.
Во многих областях текст вообще носит вспомогательный характер, а основная
информация передаётся в двумерном виде:
чертежи и схемы, всевозможные карты и планы,
рентгеновские снимки и результаты томографии,
дорожные знаки и разметка,
а ещё всякие скрам-доски и графики сгорания задач.

Работа с кодом программ - очень яркий пример повышения размерности:
подсветка синтаксиса,
форматирование кода,
свёртывание и развёртывание блоков (folding),
разнообразные дополнительные окошки со списками классов, полей и методов
и т.д.
Тем не менее, здесь текст (код) является основой, а всё остальное -
вспомогательные плюшки.
Попытки радикально повысить размерность в программировании
предпринимаются регулярно, но, в лучшем случае, остаются в своей узкой нише.
Навскидку можно вспомнить
[LabView](https://www.ni.com/en/shop/labview.html) и
[Unreal Engine Blueprints](https://docs.unrealengine.com/4.26/en-US/ProgrammingAndScripting/Blueprints/).
Визуальное проектирование в [Delphi](https://www.embarcadero.com/ru/products/delphi) -
тоже хороший пример, но там разработка в конечном счёте упирается в написание кода.

Одна из главных принципиальных сложностей программирования в том,
что я бы назвал **"когнитивным расстоянием"** между действием и результатом.
Когда мы пишем текстовый документ, или рисуем картинку,
то сразу видим их такими, какими они будут при печати:
шрифты, отступы, цвета и т.д.
Другое дело - рисование в [Mermaid](https://mermaid.js.org/intro/),
или вёрстка текста в [LaTeX](https://www.latex-project.org).
Тут мы пишем одно, а видим другое.
Нужно представить себе результат,
а потом закодировать его на определённом языке.
Так вот, в программировании это кодирование максимально далёкое от результата.
Чтобы понять как то или иное действие с исходным кодом отразится на работе
приложения нужно много когнитивных усилий.
Труднее, наверное, только генная инженерия,
где организм формируется в результате сложных химических процессов
взаимодействия белков, которые синтезируются на основе ДНК.

Тут ещё возникает вопрос, а что является результатом, который мы держим в голове?
Ответ не так уж и очевиден.
Разработчики системы [LaTeX] утверждают, что она относится к парадигме
WYSIWYM (What You See Is What You Mean),
в противовес парадигме
WYSIWYG (What You See Is What You Get).
То есть, в исходном коде мы видим не то, что получим
("жирный крупный текст"),
а то, что имеем в виду ("заголовок 1-го уровня").
Так же и в программировании: мы имеем в виду некоторые абстракции,
которые не только обеспечивают текущую работоспособность приложения
(соответствие спецификации), но и потенциал его изменения и расширения
(гибкость).
Часто эти абстракции не отражаются ни в исходном коде, ни в работе приложения,
а остаются исключительно в голове программиста.
Один из примеров - шаблоны проектирования:
в коде просто классы, и если, не назвать их определённым образом, то
можно и не догадаться, что осознанно используется какой-то паттерн.
Можно копнуть глубже.
Как глядя на всякие `JMP`, `CMP`, `JNE`, `JZ` и т.д. понять имеем ли мы дело
со спагетти, или осознанным структурным программированием по заветам Эдсгера Дейкстры?

Было бы хорошо, если бы программирование было похоже на рисование
в графическом редакторе, где можно просто двигать и связывать объекты
(и не беспокоиться об отступах и забытых скобках),
а также, легко перемещаться в трёх измерениях включая глубину
(масштаб, детализацию).
Если бы при этом можно было сократить когнитивное расстояние между действием
и результатом, было бы вообще отлично.

Позволю себе немного пофантазировать.
Как графически изобразить сложение двух целых чисел в машинных кодах?
Если глубоко не закапываться в детали реализации, то можно так:

![сложение в машинных кодах](/assets/ist-add-machine.png)

Есть процессор и память, а также коды регистров и адреса.
Выглядит сложновато.

Если мы переходим на ассеблер,
используем такие абстракции как регистры и переменные,
и при этом не задумываемся о флагах процессора,
то можно несколько упростить схему:

![сложение на ассемблере](/assets/ist-add-asm.png)

Тут я специально разделил "переменные", обладающие состоянием (`ax`, `c`),
и условные "константы" (`a`, `b`).
Состояние - это последовательность значений, и эта последовательность
для `ax` задаёт порядок выполнения процедур `mov` и `add`.
Этот графический код не императивный, а декларативный!
Здесь нет явного порядка команд (как в Unreal Engine Blueprints),
а, вместо этого, есть "оси времени" для `ax` и `c` (а раньше - для `CPU` и `RAM`).

В случае императивного кода на языке высокого уровня картина такая:

![императивное сложение](/assets/ist-add-imperative.png)

Тут три оси времени, но всего одна операция,
поэтому эти оси не играют особой роли.
Вот если бы было несколько команд, для работы с переменными `a`, `b` и `c`,
то тогда их нужно было бы упорядочить.

В декларативном стиле изменяемые состояния нам не потребуются,
и схема станет ещё проще:

![декларативное сложение](/assets/ist-add-declarative.png)

На этих четырёх картинках мы двигались вверх по измерению
"глубина"/"уровень абстракции":
  1. ассемблер даёт нам именованные регистры и ячейки памяти, вместо кодов и адресов;
  1. язык высокого уровня скрывает аппаратные детали, такие как регистры;
  1. декларативный подход делает изменяемые состояния вычислительной машины неявными.

Давайте сделаем ещё один шаг вверх, только возьмём задачу посложнее:

![дельта](/assets/ist-add-delta.png)

Здесь для наглядности используется многомерность математических выражений.
Такая картинка ближе к предметной области (математике), чем код
```Python
delta = sqrt((a + b - c) * (b + c - a) * (c + a - b) / factorial(a + b + c + 1))
```
Фактически, это графический DSL,
чем то похожий на [Mathcad](https://www.mathcad.com/en/capabilities),
который можно использовать прямо в основном (графическом) коде.

Для других предметных областей можно придумать и другие примеры.
Нужно только проявить фантазию и подумать как можно использовать
многомерные схемы, вместо привычного одномерного кода.

Раз уж у нас в формуле появился факториал, о нём в следующий раз и поговорим.
