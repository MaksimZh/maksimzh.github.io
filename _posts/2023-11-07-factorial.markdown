---
layout: post
title:  "Факториал"
date:   2023-11-07
---

Сегодня просмотрим несколько вариантов реализации функции вычисления факториала.
Обычно рассматривается два варианта - с циклом и рекурсией.


# Цикл с условием
Начнём с циклов, но не с `for`, как обычно,
а с более общей формы - цикл с условием.
Как нарисовать цикл в многомерном программировании, если у нас нет передачи
управления в явном виде?
Можно рассматривать тело цикла как **замыкание**, которое использует
внешние (по отношению к циклу) переменные и возвращает булевское значение,
которое сигнализирует, нужно ли продолжать цикл.
Тогда на поверхности функция выглядит так:

![факториал с циклом с постусловием](/assets/fac-loop-post.png)

а если пойти на один шаг в глубину, то тело цикла будет таким:

![тело цикла с постусловием](/assets/fac-loop-post-body.png)

Звёздочки на первом рисунке означают, что процедура может менять
состояние.
Поэтому состояния `i` и `r` на втором рисунке как бы проходят сквозь всю
процедуру, являясь одновременно и входными и выходными параметрами.
Начальные значения для них задаются вне тела цикла.

Функция на втором рисунке возвращает значение `continue`,
которое управляет выполнением цикла.
Видно, что это цикл с постусловием, то есть его тело выполняется
по крайней мере один раз.
Поэтому мы начинаем с единицы, а не двойки.
Если бы мы использовали цикл с предусловием, то для проверки условия
понадобилась бы отдельная функция,
потому что в этом случае тело может не выполнится вообще ни разу.

Состояния вне тела цикла анонимны (не имеют имён), хотя второе (`r`)
в конце выполнения функции связывается с выходным значением `result`.
При этом нельзя спрятать `i` внутрь тела цикла, потому что это
состояние одно и то же для всех итераций.
Можно, правда, спрятать его посередине - внутри самой абстракции цикла.
Про это в следующем разделе.


# Цикл по диапазону значений
Это классический цикл `for`, который берёт на себя операции перебора
значений счётчика.
В программе он используется так:

![факториал с циклом for](/assets/fac-loop-range.png)

На вход он получает последовательность значений и внешние переменные,
с которым будет цикл.
Тело цикла при этом становится намного проще:

![тело цикла for](/assets/fac-loop-range-body.png)

Больше не нужно вручную увеличивать счётчик и сравнивать его с максимальным
значением.

Кстати, последовательность, по которой происходит перебор,
передаётся между процедурами анонимно,
под неё не заводится отдельный идентификатор.
При этом не возникает вложенных вызовов, которые в одномерных текстовых
языках программирования могут быть очень неудобными из-за большого
количества открывающихся и закрывающихся скобок.


# Рекурсия
Рекурсивная версия этой функции должна содержать конструкцию,
который определяет когда пора заканчивать расчёт и возвращать значение.
Без явной передачей управления это может быть оператор выбора
одного из двух значений:

![рекурсивная версия факториала](/assets/fac-rec.png)

Может показаться, что выполнение этой функции никогда не закончится,
ведь оператору `if` всегда требуется значение для случая `false`.
Это не так!
Схема показывает как входы и выходы процедур связаны со значениями,
но не означает, что каждая процедура будет выполнена,
и каждое значение будет обязательно вычислено.

Как же будут проходить вычисления?
Есть две крайних стратегии:

  - **жадная**: как только процедура получает все входные значения,
    она выполняется и вычисляет все выходные значения;
  - **ленивая**: процедура запрашивает входные значения когда запрошено одно
    из её выходных значений и выполняется, когда получит все входные значения.

Возможны также разные промежуточные варианты, когда одни процедуры будут
жадными, а другие - ленивыми.
Входные значения оператора `if` полезно вычислять ленивым способом
с точки зрения оптимизации, но для рекурсии это уже не опция, а необходимость.
В идеале, планированием выполнения процедур должен заниматься компилятор,
который, в данном случае, должен обеспечить конечность рекурсии за счёт
ленивого вычисления ветки `false`.

На рисунке выше есть две процедуры (`<2` и `n*(n-1)!`),
которые не выглядят, как типичная часть какого-то языка программирования
или его стандартной библиотеки.
Вот что они означают:

`<2`

![блок <2](/assets/fac-rec-less2.png)

`n*(n-1)!`

![блок n*(n-1)!](/assets/fac-rec-iter.png)

В одномерном программировании нужно было бы оформлять эти блоки как функции,
но здесь можно использовать одно из преимуществ многомерного подхода - глубину.
В некотором смысле это аналог вложенных функций / лямбда выражений
(например в Python) или оператора `where` в Haskell.
Только здесь они не совсем не занимают места в теле основной функции.
Если сделать такую IDE, то можно будет раскрывать и сворачивать
эти блоки по желанию разработчика прямо на месте.


# Линейная версия
Теперь у нас достаточно возможностей для простой, линейной, версии:

![линейная версия факториала](/assets/fac-fun.png)

Вот такое одномерное программирование мне нравится.
Одно измерение здесь - не результат ограничений, а показатель простоты,
которая обеспечивается за счёт глубины:

`2..n`

![блок 2..n](/assets/fac-fun-seq.png)

`product`

![блок product](/assets/fac-fun-prod.png)

Здесь, вроде бы, нет принципиальных отличий от текстовых языков программированя.
На Python можно написать
```Python
factorial = lambda n: reduce(mul, range(2, n + 1), 1)
```
но это не так понятно, как `2..n` и `product`.
Тем более, что в `reduce` параметр `seed` почему-то нельзя задавать через
ключевое слово, что ещё больше усложняет понимание кода.
Когда глаз видит единичку, нужно понять, что это третий аргумент `reduce`
и вспомнить, что он означает `seed`.
Такие мелочи в сумме создают существенную когнитивную нагрузку
при работе с большим объёмом кода.

Если же мы дадим осмысленные названия для блоков,
то объём текста сразу вырастет:
```Python
def factorial(n):
    seq_2_n = range(2, n + 1)
    prod = lambda seq: reduce(mul, seq, 1)
    return prod(seq_2_n)
```
Трудность в том, что тут у нас нет глубины, и мы не можем прятать определения
для `seq_2_n` и `prod` в легкодоступном месте.
Либо они будут засорять вид, либо их придётся далеко искать
где-то в конце файла.


# Заключение
Помимо привычных функций, циклов, ветвления, рекурсии и функций высокого порядка
мы здесь увидели ещё один инструмент который мог появиться
только в многомерном программировании - глубина.
Часто функции создаются не для повторного использования, а для повышения
читаемости кода.
Когда есть глубина, то код можно прятать прямо на месте, не создавая
полноценные функции (со спецификацией, тестами и т.п.).
